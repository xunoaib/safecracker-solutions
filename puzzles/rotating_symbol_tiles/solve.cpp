// Generated by ChatGPT

#include <algorithm>
#include <array>
#include <climits>
#include <cmath>
#include <iostream>
#include <queue>
#include <random>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using Grid = std::array<std::array<int, 5>, 5>;

const std::vector<std::pair<int, int>> ROTATIONS = {
    {0, 0}, {0, 1}, {0, 2}, {0, 3}, {1, 0}, {1, 1}, {1, 2}, {1, 3},
    {2, 0}, {2, 1}, {2, 2}, {2, 3}, {3, 0}, {3, 1}, {3, 2}, {3, 3},
};

const std::unordered_set<int> BLANK_IDS = {3, 4, 9, 15, 20, 21};

void print_grid(const Grid &grid) {
    for (auto &row : grid) {
        for (auto val : row) {
            if (val == -1)
                std::cout << "  *";
            else
                std::cout << ' ' << (val < 10 ? " " : "") << val;
        }
        std::cout << '\n';
    }
    std::cout << "\n";
}

void rotate(Grid &grid, int r, int c) {
    int temp = grid[r][c];
    grid[r][c] = grid[r + 1][c];
    grid[r + 1][c] = grid[r + 1][c + 1];
    grid[r + 1][c + 1] = grid[r][c + 1];
    grid[r][c + 1] = temp;
}

Grid create_goal() {
    Grid grid;
    for (int i = 0; i < 5; ++i)
        for (int j = 0; j < 5; ++j) {
            int id = i * 5 + j;
            grid[i][j] = BLANK_IDS.count(id) ? -1 : id;
        }
    return grid;
}

Grid shuffle_grid(const Grid &goal, int steps = 12) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dist(0, ROTATIONS.size() - 1);

    Grid shuffled = goal;
    for (int i = 0; i < steps; ++i) {
        auto [r, c] = ROTATIONS[dist(gen)];
        rotate(shuffled, r, c);
    }
    return shuffled;
}

struct GridHasher {
    std::size_t operator()(const Grid &g) const {
        std::size_t h = 0;
        for (auto &row : g)
            for (int val : row)
                h ^= std::hash<int>()(val) + 0x9e3779b9 + (h << 6) + (h >> 2);
        return h;
    }
};

std::pair<int, int> find_tile(const Grid &grid, int tile) {
    for (int i = 0; i < 5; ++i)
        for (int j = 0; j < 5; ++j)
            if (grid[i][j] == tile)
                return {i, j};
    return {-1, -1};
}

int heuristic(const Grid &a, const Grid &goal, int target_tile) {
    std::unordered_map<int, std::pair<int, int>> goal_pos;
    std::vector<std::pair<int, int>> goal_blanks, current_blanks;

    for (int i = 0; i < 5; ++i)
        for (int j = 0; j < 5; ++j) {
            int val_goal = goal[i][j];
            int val_cur = a[i][j];

            if (val_goal == -1)
                goal_blanks.emplace_back(i, j);
            else if (val_goal <= target_tile)
                goal_pos[val_goal] = {i, j};

            if (val_cur == -1)
                current_blanks.emplace_back(i, j);
        }

    int h = 0;

    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j) {
            int val = a[i][j];
            if (val != -1 && val <= target_tile && goal_pos.count(val)) {
                auto [gi, gj] = goal_pos[val];
                h += std::abs(i - gi) + std::abs(j - gj);
            }
        }
    }

    // Optional: You can re-enable this block if you want blank matching early
    /*
    int blank_distance = 0;
    std::vector<bool> used(current_blanks.size(), false);
    for (const auto &[gi, gj] : goal_blanks) {
        int min_dist = INT_MAX;
        int best_idx = -1;
        for (size_t k = 0; k < current_blanks.size(); ++k) {
            if (used[k]) continue;
            const auto &[ci, cj] = current_blanks[k];
            int dist = std::abs(gi - ci) + std::abs(gj - cj);
            if (dist < min_dist) {
                min_dist = dist;
                best_idx = k;
            }
        }
        if (best_idx != -1) {
            used[best_idx] = true;
            blank_distance += min_dist;
        }
    }
    return static_cast<int>(0.5 * h + 0.5 * blank_distance);
    */

    return h;
}

bool rotation_touches_solved(int r, int c, const Grid &grid, const Grid &goal,
                             int locked_up_to) {
    for (int dr = 0; dr < 2; ++dr)
        for (int dc = 0; dc < 2; ++dc) {
            int val = grid[r + dr][c + dc];
            if (val != -1 && val <= locked_up_to) {
                auto [gi, gj] = find_tile(goal, val);
                if (r + dr != gi || c + dc != gj)
                    return true;
            }
        }
    return false;
}

std::pair<Grid, std::vector<std::pair<int, int>>>
solve_one_by_one(Grid start, const Grid &goal) {

    std::vector<std::pair<int, int>> full_path;

    for (int target = 0; target <= 9; ++target) {
        std::cout << "Solving " << target << std::endl;
        if (BLANK_IDS.count(target))
            continue;

        auto is_solved = [&]() {
            auto [ri, ci] = find_tile(start, target);
            auto [rg, cg] = find_tile(goal, target);
            return ri == rg && ci == cg;
        };

        if (is_solved())
            continue;

        using State =
            std::tuple<int, int, Grid, std::vector<std::pair<int, int>>>;
        auto cmp = [](const State &a, const State &b) {
            return std::get<0>(a) > std::get<0>(b);
        };

        std::priority_queue<State, std::vector<State>, decltype(cmp)> pq(cmp);
        std::unordered_set<Grid, GridHasher> visited;

        int h0 = heuristic(start, goal, target);
        pq.emplace(h0, 0, start, std::vector<std::pair<int, int>>{});
        visited.insert(start);

        bool solved = false;
        while (!pq.empty()) {
            auto [f, g, state, path] = pq.top();
            pq.pop();

            if (find_tile(state, target) == find_tile(goal, target)) {
                start = state;
                full_path.insert(full_path.end(), path.begin(), path.end());
                solved = true;
                break;
            }

            for (auto [r, c] : ROTATIONS) {
                if (rotation_touches_solved(r, c, state, goal, target - 1))
                    continue;

                Grid new_state = state;
                rotate(new_state, r, c);
                if (!visited.count(new_state)) {
                    auto new_path = path;
                    new_path.emplace_back(r, c);
                    int g_new = g + 1;
                    int f_new = g_new + heuristic(new_state, goal, target);
                    pq.emplace(f_new, g_new, new_state, new_path);
                    visited.insert(new_state);
                }
            }
        }

        if (!solved) {
            std::cout << "Failed to solve tile " << target << '\n';
            break;
        }
    }

    return {start, full_path};
}

std::vector<std::pair<int, int>> solve(const Grid &start, const Grid &goal) {
    using State = std::tuple<int, int, Grid, std::vector<std::pair<int, int>>>;
    auto cmp = [](const State &a, const State &b) {
        return std::get<0>(a) > std::get<0>(b);
    };

    std::priority_queue<State, std::vector<State>, decltype(cmp)> pq(cmp);
    std::unordered_set<Grid, GridHasher> visited;

    int h0 = heuristic(start, goal, 24); // heuristic for full puzzle
    pq.emplace(h0, 0, start, std::vector<std::pair<int, int>>{});
    visited.insert(start);

    while (!pq.empty()) {
        auto [f, g, state, path] = pq.top();
        pq.pop();

        if (state == goal)
            return path;

        for (auto [r, c] : ROTATIONS) {
            Grid new_state = state;
            rotate(new_state, r, c);
            if (!visited.count(new_state)) {
                auto new_path = path;
                new_path.emplace_back(r, c);
                int g_new = g + 1;
                int f_new = g_new + heuristic(new_state, goal, 24);
                pq.emplace(f_new, g_new, new_state, new_path);
                visited.insert(new_state);
            }
        }
    }

    return {};
}

int main() {
    Grid goal = create_goal();
    Grid start = shuffle_grid(goal, 12);

    std::cout << "Initial state:\n";
    print_grid(start);
    std::cout << "Goal state:\n";
    print_grid(goal);

    auto [partial_state, partial_path] = solve_one_by_one(start, goal);
    std::cout << "Solving remaining" << std::endl;
    auto final_path = solve(partial_state, goal);

    std::vector<std::pair<int, int>> full_path = partial_path;
    full_path.insert(full_path.end(), final_path.begin(), final_path.end());

    std::cout << "Solved in " << full_path.size() << " moves:\n";
    for (auto [r, c] : full_path)
        std::cout << "Rotate at (" << r << ", " << c << ")\n";

    return 0;
}
